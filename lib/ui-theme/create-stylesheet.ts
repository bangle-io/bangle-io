import { getFromPath, vars, walkObject } from '@bangle.io/atomic-css';
import type { BangleThemeInput, DesignTokens } from '@bangle.io/shared-types';

import { createTokens } from './create-tokens';
import type { BangleAppOverrides } from './types';

if (typeof window !== 'undefined') {
  // This package is only meant to be used for creating stylesheets in node.js
  throw new Error('This file should not be imported in browser');
}

export function createStyleSheet(
  theme: BangleThemeInput,
  appOverride?: BangleAppOverrides,
) {
  if ('light' in theme.color && !('dark' in theme.color)) {
    throw new Error('theme color must have both light and dark or none');
  }

  if ('dark' in theme.color && !('light' in theme.color)) {
    throw new Error('theme color must have both light and dark or none');
  }

  const tokens = createTokens(theme, appOverride);

  let bareMinimums = setBareMinimums();

  if (!Array.isArray(tokens)) {
    return appendBlock(
      bareMinimums,
      wrapVarsCss(':root', cssVarsToStrArray(convertTokensToVars(tokens))),
    );
  }

  const common = new Set<string>();

  const lightVarsSet = new Set(
    cssVarsToStrArray(
      convertTokensToVars(tokens.find((t) => t.uid.endsWith('-light'))!),
    ),
  );

  const darkVarsSet = new Set(
    cssVarsToStrArray(
      convertTokensToVars(tokens.find((t) => t.uid.endsWith('-dark'))!),
    ),
  );

  let lightVars: string[] = [];

  lightVarsSet.forEach((item) => {
    if (darkVarsSet.has(item)) {
      common.add(item);
    } else {
      lightVars.push(item);
    }
  });

  let darkVars: string[] = [];

  darkVarsSet.forEach((item) => {
    if (lightVarsSet.has(item)) {
      common.add(item);
    } else {
      darkVars.push(item);
    }
  });

  let str = bareMinimums;

  str = appendBlock(str, wrapVarsCss(':root', [...common]));
  str = appendBlock(
    str,
    wrapVarsCss(".light-theme, html[data-theme='light']", [...lightVars]),
  );

  str = appendBlock(
    str,
    wrapVarsCss(".dark-theme, html[data-theme='dark']", [...darkVars]),
  );

  return str;
}

function cssVarsToStrArray(vars: Array<[string, string]>) {
  return vars.map(([property, value]) => `  ${property}: ${value};`);
}

function convertTokensToVars(_tokens: DesignTokens): Array<[string, string]> {
  let tokens = _tokens;
  let result: Array<[string, string]> = [];

  walkObject(vars, (value, path) => {
    if (!value.startsWith('var(') && !value.endsWith(')')) {
      throw new Error('Invalid value ' + value);
    }

    let property = value.slice('var('.length, -1);

    value = getFromPath(tokens, path);

    // remove uid from tokens as it does  have any use in css vars
    if (!property.endsWith('-uid')) {
      result.push([property, value]);
    }
  });

  return result;
}

function wrapVarsCss(header: string, cssLines: string[]) {
  return `/* WARNING: This is autogenerated do not modify! */
/* stylelint-disable */
${header} {
  ${cssLines.join('\n')}
}
/* stylelint-enable */`.trim();
}

function setBareMinimums() {
  return wrapVarsCss('body', [
    `  background-color: ${vars.color.neutral.bgLayerBottom};`,
    `  color: ${vars.color.neutral.text};`,
  ]);
}

function appendBlock(sourceStr: string, blockStr: string): string {
  return sourceStr + '\n\n' + blockStr;
}
