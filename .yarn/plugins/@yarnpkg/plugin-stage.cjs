/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-stage",
factory: function (require) {var plugin;plugin=(()=>{"use strict";var t={917:(t,e,n)=>{n.r(e),n.d(e,{default:()=>y});const a=require("@yarnpkg/cli"),i=require("@yarnpkg/core"),s=require("@yarnpkg/fslib"),o=require("clipanion");var r;async function c(t,{marker:e}){do{if(s.xfs.existsSync(s.ppath.join(t,e)))return t;t=s.ppath.dirname(t)}while("/"!==t);return null}function l(t,e){let n=0,a=0;for(const i of t)"wip"!==i&&(e.test(i)?n+=1:a+=1);return n>=a}!function(t){t[t.CREATE=0]="CREATE",t[t.DELETE=1]="DELETE",t[t.ADD=2]="ADD",t[t.REMOVE=3]="REMOVE",t[t.MODIFY=4]="MODIFY"}(r||(r={}));const d=new Map([[r.CREATE,"create"],[r.DELETE,"delete"],[r.ADD,"add"],[r.REMOVE,"remove"],[r.MODIFY,"update"]]);async function u(t){const{code:e,stdout:n}=await i.execUtils.execvp("git",["log","-1","--pretty=format:%H"],{cwd:t});return 0===e?n.trim():null}async function p(t,e){const n=[],a=e.filter(t=>"package.json"===s.ppath.basename(t.path));for(const{action:e,path:o}of a){const a=s.ppath.relative(t,o);if(e===r.MODIFY){const e=await u(t),{stdout:s}=await i.execUtils.execvp("git",["show",`${e}:${a}`],{cwd:t,strict:!0}),c=await i.Manifest.fromText(s),l=await i.Manifest.fromFile(o),d=new Map([...l.dependencies,...l.devDependencies]),p=new Map([...c.dependencies,...c.devDependencies]);for(const[t,e]of p){const a=i.structUtils.stringifyIdent(e),s=d.get(t);s?s.range!==e.range&&n.push([r.MODIFY,`${a} to ${s.range}`]):n.push([r.REMOVE,a])}for(const[t,e]of d)p.has(t)||n.push([r.ADD,i.structUtils.stringifyIdent(e)])}else if(e===r.CREATE){const t=await i.Manifest.fromFile(o);t.name?n.push([r.CREATE,i.structUtils.stringifyIdent(t.name)]):n.push([r.CREATE,"a package"])}else{if(e!==r.DELETE)throw new Error("Assertion failed: Unsupported action type");{const e=await u(t),{stdout:s}=await i.execUtils.execvp("git",["show",`${e}:${a}`],{cwd:t,strict:!0}),o=await i.Manifest.fromText(s);o.name?n.push([r.DELETE,i.structUtils.stringifyIdent(o.name)]):n.push([r.DELETE,"a package"])}}}const{code:o,stdout:c}=await i.execUtils.execvp("git",["log","-11","--pretty=format:%s"],{cwd:t});return function(t,e){const n=function(t){return t.useComponent?"chore(yarn): ":""}(t),a=[],i=e.slice().sort((t,e)=>t[0]-e[0]);for(;i.length>0;){const[e,n]=i.shift();let s=d.get(e);t.useUpperCase&&0===a.length&&(s=`${s[0].toUpperCase()}${s.slice(1)}`),t.useThirdPerson&&(s+="s");const o=[n];for(;i.length>0&&i[0][0]===e;){const[,t]=i.shift();o.push(t)}o.sort();let r=o.shift();1===o.length?r+=" (and one other)":o.length>1&&(r+=` (and ${o.length} others)`),a.push(`${s} ${r}`)}return`${n}${a.join(", ")}`}(function(t){return{useThirdPerson:l(t,/^(\w\(\w+\):\s*)?\w+s/),useUpperCase:l(t,/^(\w\(\w+\):\s*)?[A-Z]/),useComponent:l(t,/^\w\(\w+\):/)}}(0===o?c.split(/\n/g).filter(t=>""!==t):[]),n)}const h={[r.CREATE]:[" A ","?? "],[r.MODIFY]:[" M "],[r.DELETE]:[" D "]},f={[r.CREATE]:["A  "],[r.MODIFY]:["M  "],[r.DELETE]:["D  "]},g=[{findRoot:async t=>await c(t,{marker:".git"}),async filterChanges(t,e,n,a){const{stdout:o}=await i.execUtils.execvp("git",["status","-s"],{cwd:t,strict:!0}),c=o.toString().split(/\n/g),l=(null==a?void 0:a.staged)?f:h;return[].concat(...c.map(e=>{if(""===e)return[];const n=e.slice(0,3),i=s.ppath.resolve(t,e.slice(3));if(!(null==a?void 0:a.staged)&&"?? "===n&&e.endsWith("/"))return function(t){const e=[],n=[t];for(;n.length>0;){const t=n.pop(),a=s.xfs.readdirSync(t);for(const i of a){const a=s.ppath.resolve(t,i);s.xfs.lstatSync(a).isDirectory()?n.push(a):e.push(a)}}return e}(i).map(t=>({action:r.CREATE,path:t}));{const t=[r.CREATE,r.MODIFY,r.DELETE].find(t=>l[t].includes(n));return void 0!==t?[{action:t,path:i}]:[]}})).filter(t=>function(t,{roots:e,names:n}){if(n.has(s.ppath.basename(t)))return!0;do{if(e.has(t))return!0;t=s.ppath.dirname(t)}while("/"!==t);return!1}(t.path,{roots:e,names:n}))},genCommitMessage:async(t,e)=>await p(t,e),async makeStage(t,e){const n=e.map(t=>s.npath.fromPortablePath(t.path));await i.execUtils.execvp("git",["add","--",...n],{cwd:t,strict:!0})},async makeCommit(t,e,n){const a=e.map(t=>s.npath.fromPortablePath(t.path));await i.execUtils.execvp("git",["add","-N","--",...a],{cwd:t,strict:!0}),await i.execUtils.execvp("git",["commit","-m",n+"\n\nCommit generated via `yarn stage`\n","--",...a],{cwd:t,strict:!0})},async makeReset(t,e){const n=e.map(t=>s.npath.fromPortablePath(t.path));await i.execUtils.execvp("git",["reset","HEAD","--",...n],{cwd:t,strict:!0})}},{findRoot:async t=>await c(t,{marker:".hg"}),filterChanges:async(t,e,n)=>[],genCommitMessage:async(t,e)=>"",async makeStage(t,e){},async makeCommit(t,e,n){},async makeReset(t,e){},async makeUpdate(t,e){}}];class m extends a.BaseCommand{constructor(){super(...arguments),this.commit=o.Option.Boolean("-c,--commit",!1,{description:"Commit the staged files"}),this.reset=o.Option.Boolean("-r,--reset",!1,{description:"Remove all files from the staging area"}),this.dryRun=o.Option.Boolean("-n,--dry-run",!1,{description:"Print the commit message and the list of modified files without staging / committing"}),this.update=o.Option.Boolean("-u,--update",!1,{hidden:!0})}async execute(){const t=await i.Configuration.find(this.context.cwd,this.context.plugins),{project:e}=await i.Project.find(t,this.context.cwd),{driver:n,root:a}=await async function(t){let e=null,n=null;for(const a of g)if(null!==(n=await a.findRoot(t))){e=a;break}if(null===e||null===n)throw new o.UsageError("No stage driver has been found for your current project");return{driver:e,root:n}}(e.cwd),r=[t.get("cacheFolder"),t.get("globalFolder"),t.get("virtualFolder"),t.get("yarnPath")];await t.triggerHook(t=>t.populateYarnPaths,e,t=>{r.push(t)});const c=new Set;for(const t of r)for(const e of w(a,t))c.add(e);const l=new Set([t.get("rcFilename"),t.get("lockfileFilename"),"package.json"]),d=await n.filterChanges(a,c,l),u=await n.genCommitMessage(a,d);if(this.dryRun)if(this.commit)this.context.stdout.write(u+"\n");else for(const t of d)this.context.stdout.write(s.npath.fromPortablePath(t.path)+"\n");else if(this.reset){const t=await n.filterChanges(a,c,l,{staged:!0});0===t.length?this.context.stdout.write("No staged changes found!"):await n.makeReset(a,t)}else 0===d.length?this.context.stdout.write("No changes found!"):this.commit?await n.makeCommit(a,d,u):(await n.makeStage(a,d),this.context.stdout.write(u))}}function w(t,e){const n=[];if(null===e)return n;for(;;){let a;(e===t||e.startsWith(t+"/"))&&n.push(e);try{a=s.xfs.statSync(e)}catch(t){break}if(!a.isSymbolicLink())break;e=s.ppath.resolve(s.ppath.dirname(e),s.xfs.readlinkSync(e))}return n}m.paths=[["stage"]],m.usage=o.Command.Usage({description:"add all yarn files to your vcs",details:"\n      This command will add to your staging area the files belonging to Yarn (typically any modified `package.json` and `.yarnrc.yml` files, but also linker-generated files, cache data, etc). It will take your ignore list into account, so the cache files won't be added if the cache is ignored in a `.gitignore` file (assuming you use Git).\n\n      Running `--reset` will instead remove them from the staging area (the changes will still be there, but won't be committed until you stage them back).\n\n      Since the staging area is a non-existent concept in Mercurial, Yarn will always create a new commit when running this command on Mercurial repositories. You can get this behavior when using Git by using the `--commit` flag which will directly create a commit.\n    ",examples:[["Adds all modified project files to the staging area","yarn stage"],["Creates a new commit containing all modified project files","yarn stage --commit"]]});const y={commands:[m]}}},e={};function n(a){if(e[a])return e[a].exports;var i=e[a]={exports:{}};return t[a](i,i.exports,n),i.exports}return n.d=(t,e)=>{for(var a in e)n.o(e,a)&&!n.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:e[a]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n(917)})();return plugin;
}
};